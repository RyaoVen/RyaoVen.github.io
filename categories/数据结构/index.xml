<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>数据结构 on VenKing_Ryao的个人博客</title>
        <link>http://localhost:1313/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</link>
        <description>Recent content in 数据结构 on VenKing_Ryao的个人博客</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>zh-cn</language>
        <copyright>VenKing_Ryao-HEUN</copyright>
        <lastBuildDate>Sat, 23 Nov 2024 00:00:00 +0000</lastBuildDate><atom:link href="http://localhost:1313/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/index.xml" rel="self" type="application/rss+xml" /><item>
        <title>数据结构算法积累</title>
        <link>http://localhost:1313/p/suanfa/</link>
        <pubDate>Sat, 23 Nov 2024 00:00:00 +0000</pubDate>
        
        <guid>http://localhost:1313/p/suanfa/</guid>
        <description>&lt;img src="http://localhost:1313/images/studying1.jpg" alt="Featured image of post 数据结构算法积累" /&gt;&lt;p&gt;本质上算法只是一种思维方式，语言只是其载体，是故用任何语言积累数据结构都可以。因此笔者便不统一书写语言了，将写题时的随笔记下，也随便督促读者去多学点基础语法知识，毕竟技多不压身，能多学一点总是好的。&lt;/p&gt;
&lt;h2 id=&#34;画饼-缓慢更新中可以催更&#34;&gt;画饼 （缓慢更新中，可以催更）
&lt;/h2&gt;&lt;p&gt;基础的数据结构和算法是计算机科学中的核心概念，以下是一些常见的数据结构和算法分类：&lt;/p&gt;
&lt;h3 id=&#34;数据结构&#34;&gt;数据结构：
&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;数组（Array）&lt;/strong&gt;：一种基础的数据结构，用于存储一系列相同类型的数据。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;链表（Linked List）&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;单链表&lt;/li&gt;
&lt;li&gt;双链表&lt;/li&gt;
&lt;li&gt;循环链表&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;栈（Stack）&lt;/strong&gt;：后进先出（LIFO）的数据结构。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;队列（Queue）&lt;/strong&gt;：先进先出（FIFO）的数据结构。
&lt;ul&gt;
&lt;li&gt;循环队列&lt;/li&gt;
&lt;li&gt;双端队列（Deque）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;树（Tree）&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;二叉树&lt;/li&gt;
&lt;li&gt;平衡二叉树（AVL树）&lt;/li&gt;
&lt;li&gt;红黑树&lt;/li&gt;
&lt;li&gt;B树、B+树&lt;/li&gt;
&lt;li&gt;堆（Heap）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;图（Graph）&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;有向图&lt;/li&gt;
&lt;li&gt;无向图&lt;/li&gt;
&lt;li&gt;加权图&lt;/li&gt;
&lt;li&gt;连通图&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;哈希表（Hash Table）&lt;/strong&gt;：通过哈希函数实现快速查找的数据结构。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;集合（Set）&lt;/strong&gt;：一种抽象数据类型，用于存储无序且不重复的元素。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;字典（Dictionary）/映射（Map）&lt;/strong&gt;：一种抽象数据类型，用于存储键值对。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;算法&#34;&gt;算法：
&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;排序算法&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;冒泡排序&lt;/li&gt;
&lt;li&gt;选择排序&lt;/li&gt;
&lt;li&gt;插入排序&lt;/li&gt;
&lt;li&gt;快速排序&lt;/li&gt;
&lt;li&gt;归并排序&lt;/li&gt;
&lt;li&gt;堆排序&lt;/li&gt;
&lt;li&gt;希尔排序&lt;/li&gt;
&lt;li&gt;计数排序&lt;/li&gt;
&lt;li&gt;基数排序&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;搜索算法&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;顺序搜索&lt;/li&gt;
&lt;li&gt;二分搜索&lt;/li&gt;
&lt;li&gt;深度优先搜索（DFS）&lt;/li&gt;
&lt;li&gt;广度优先搜索（BFS）&lt;/li&gt;
&lt;li&gt;A*搜索&lt;/li&gt;
&lt;li&gt;贪心搜索&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;字符串匹配算法&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;朴素字符串匹配&lt;/li&gt;
&lt;li&gt;KMP算法&lt;/li&gt;
&lt;li&gt;Rabin-Karp算法&lt;/li&gt;
&lt;li&gt;Boyer-Moore算法&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;图算法&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;拓扑排序&lt;/li&gt;
&lt;li&gt;最短路径算法（Dijkstra、Bellman-Ford、Floyd-Warshall）&lt;/li&gt;
&lt;li&gt;最小生成树算法（Prim、Kruskal）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;更复杂的数据结构&#34;&gt;更复杂的数据结构：
&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;跳表（Skip List）&lt;/strong&gt;：用于快速查找的有序数据结构，可以看作是多层链表的结合。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;并查集（Union-Find）&lt;/strong&gt;：一种数据结构，用于处理一些不交集的合并及查询问题。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;线段树（Segment Tree）&lt;/strong&gt;：用于高效解决区间查询和更新问题。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;树状数组（Binary Indexed Tree）/斐波那契堆（Fibonacci Heap）&lt;/strong&gt;：用于高效处理范围查询和动态修改的问题。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Trie（前缀树）&lt;/strong&gt;：用于高效地存储和检索字符串数据集中的键。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;布隆过滤器（Bloom Filter）&lt;/strong&gt;：一种空间效率极高的数据结构，用于测试一个元素是否属于集合，有可能会出现误判。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;LSM树（Log-Structured Merge-Tree）&lt;/strong&gt;：通常用于键值存储系统中，例如LevelDB和Cassandra。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;倒排索引（Inverted Index）&lt;/strong&gt;：常用于全文搜索引擎，如Elasticsearch和Solr。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;高级算法技巧&#34;&gt;高级算法技巧：
&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;分治算法（Divide and Conquer）&lt;/strong&gt;：将问题分解成若干个小问题递归求解，然后再合并结果。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;动态规划（Dynamic Programming）&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;斐波那契数列&lt;/li&gt;
&lt;li&gt;最长公共子序列（LCS）&lt;/li&gt;
&lt;li&gt;最长递增子序列（LIS）&lt;/li&gt;
&lt;li&gt;0-1背包问题&lt;/li&gt;
&lt;li&gt;编辑距离（Levenshtein距离）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;贪心算法（Greedy Algorithms）&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;最小生成树（Prim、Kruskal）&lt;/li&gt;
&lt;li&gt;哈夫曼编码&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;回溯算法（Backtracking）&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;N皇后问题&lt;/li&gt;
&lt;li&gt;子集和问题&lt;/li&gt;
&lt;li&gt;组合问题&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;分支限界法（Branch and Bound）&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;旅行商问题（TSP）&lt;/li&gt;
&lt;li&gt;零一背包问题&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;启发式算法（Heuristic Algorithms）&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;A*搜索算法&lt;/li&gt;
&lt;li&gt;蚁群优化（ACO）&lt;/li&gt;
&lt;li&gt;粒子群优化（PSO）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;随机化算法（Randomized Algorithms）&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;蒙特卡洛算法&lt;/li&gt;
&lt;li&gt;拉斯维加斯算法&lt;/li&gt;
&lt;li&gt;跳跃表&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;近似算法（Approximation Algorithms）&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;用于在多项式时间内找到近似最优解的算法，适用于NP难问题。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;流算法（Streaming Algorithms）&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;用于处理大量数据流的算法，通常只需要一次或几次数据遍历。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;字符串匹配算法&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;后缀数组&lt;/li&gt;
&lt;li&gt;后缀树&lt;/li&gt;
&lt;li&gt;正则表达式匹配&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;查找&#34;&gt;查找
&lt;/h2&gt;&lt;p&gt;通常的，在我们需要进行查找时，使用遍历查找一个一个检查过去便能满足我们的需求，在数据量很小时使用其他的方法甚至会使代码的时间复杂度上升，但当我们处理大数据量时，遍历的效率过于低下，因此我们需要一些特殊的方法进行查找：&lt;/p&gt;
&lt;h3 id=&#34;二分查找&#34;&gt;二分查找
&lt;/h3&gt;&lt;p&gt;二分查找的核心思路是高中数学中的二分法，每次取范围的百分之50，可以快速锁定目标数据所处区间。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;22
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;23
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;24
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;25
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;26
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;27
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;28
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;29
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;30
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;31
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;32
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;33
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cp&#34;&gt;#include&lt;/span&gt; &lt;span class=&#34;cpf&#34;&gt;&amp;lt;iostream&amp;gt;&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cp&#34;&gt;#include&lt;/span&gt; &lt;span class=&#34;cpf&#34;&gt;&amp;lt;vector&amp;gt;&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cp&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// 二分查找函数
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// 参数：
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// nums - 有序数组
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// target - 要查找的目标值
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// 返回值：
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// 目标值在数组中的索引，如果未找到则返回-1
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;binarySearch&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;const&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;std&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;vector&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&amp;amp;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;nums&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;target&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;left&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;        &lt;span class=&#34;c1&#34;&gt;// 查找范围的左边界
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;right&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;nums&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;size&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// 查找范围的右边界
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;while&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;left&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;right&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// 当左边界小于等于右边界时继续查找
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;        &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;mid&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;left&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;right&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;left&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;/&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// 计算中间位置，避免直接相加可能导致的溢出
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;nums&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;mid&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;target&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            &lt;span class=&#34;c1&#34;&gt;// 如果中间位置的元素等于目标值，返回中间位置的索引
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;            &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;mid&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;else&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;nums&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;mid&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;target&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            &lt;span class=&#34;c1&#34;&gt;// 如果中间位置的元素小于目标值，将左边界设置为中间位置加一
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;            &lt;span class=&#34;c1&#34;&gt;// 因为中间位置的元素已经不可能是目标值了，所以可以排除这部分
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;            &lt;span class=&#34;n&#34;&gt;left&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;mid&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;else&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            &lt;span class=&#34;c1&#34;&gt;// 如果中间位置的元素大于目标值，将右边界设置为中间位置减一
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;            &lt;span class=&#34;c1&#34;&gt;// 同样，中间位置的元素已经不可能是目标值了，排除这部分
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;            &lt;span class=&#34;n&#34;&gt;right&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;mid&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;c1&#34;&gt;// 如果循环结束仍未找到目标值，返回-1
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;简而言之，二分查找的思路如下：首先确定查找范围的边界，然后取中间值并与目标值比较，然后将边界迁移至目标值所在的范围内，重复以下操作，以最终确定目标值的位置。
&lt;code&gt;注：二分查找的前提是所有元素有序排列。&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&#34;动态规划臭名昭著的dp&#34;&gt;动态规划(&lt;del&gt;臭名昭著的&lt;/del&gt;DP)
&lt;/h2&gt;&lt;h2 id=&#34;差分法&#34;&gt;差分法
&lt;/h2&gt;&lt;p&gt;差分法一般用于减小一维数组的运算量，假设这里有一个长度为n的数组a，那么我们建立一个数组diff_a用于记录a[i]与a[i+1]的差值，这个差值本身就是差分。&lt;/p&gt;
&lt;p&gt;例如这里有一个非常长的数组a，我们要在a[x]到a&lt;a class=&#34;link&#34; href=&#34;x%e4%ba%8ey%e4%b9%8b%e9%97%b4%e7%9a%84%e8%b7%9d%e7%a6%bb%e4%b9%9f%e9%9d%9e%e5%b8%b8%e9%95%bf&#34; &gt;y&lt;/a&gt;，我们要对这一堆数据进行相同的操作，例如加减赋值，在这里我们就以加值为例。因为a[i]可以用diff[i-1]到diff[i]+a[1]的累加和表示，所以当我们为diff[i-1]加上一个值后，在a[i]本身与之后所有用差分还原的值均加上了这个值，反之可以在a[i]本身与之后减去这个值。&lt;/p&gt;
&lt;p&gt;利用这一点，我们便可以在diff[x-1]处加上这个值，在diff[y-1]处减去这个值，以完成在a[x]到a[y]处的加值操作。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;以下是洛谷例题示例：&lt;/strong&gt;&lt;/p&gt;
</description>
        </item>
        
    </channel>
</rss>
