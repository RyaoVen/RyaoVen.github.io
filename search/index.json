[{"content":"前言：\n憋看了，现在哪有时间写，忙着数据结构跟期末考试，寒假开坑。\nPython学习前置 环境配置 IDE安装与使用教程 ","date":"2024-11-23T00:00:00Z","image":"http://localhost:1313/images/studying1.jpg","permalink":"http://localhost:1313/p/py/","title":"Python语法笔记"},{"content":"本质上算法只是一种思维方式，语言只是其载体，是故用任何语言积累数据结构都可以。因此笔者便不统一书写语言了，将写题时的随笔记下，也随便督促读者去多学点基础语法知识，毕竟技多不压身，能多学一点总是好的。\n画饼 （缓慢更新中，可以催更） 基础的数据结构和算法是计算机科学中的核心概念，以下是一些常见的数据结构和算法分类：\n数据结构： 数组（Array）：一种基础的数据结构，用于存储一系列相同类型的数据。 链表（Linked List）： 单链表 双链表 循环链表 栈（Stack）：后进先出（LIFO）的数据结构。 队列（Queue）：先进先出（FIFO）的数据结构。 循环队列 双端队列（Deque） 树（Tree）： 二叉树 平衡二叉树（AVL树） 红黑树 B树、B+树 堆（Heap） 图（Graph）： 有向图 无向图 加权图 连通图 哈希表（Hash Table）：通过哈希函数实现快速查找的数据结构。 集合（Set）：一种抽象数据类型，用于存储无序且不重复的元素。 字典（Dictionary）/映射（Map）：一种抽象数据类型，用于存储键值对。 算法： 排序算法：\n冒泡排序 选择排序 插入排序 快速排序 归并排序 堆排序 希尔排序 计数排序 基数排序 搜索算法：\n顺序搜索 二分搜索 深度优先搜索（DFS） 广度优先搜索（BFS） A*搜索 贪心搜索 字符串匹配算法：\n朴素字符串匹配 KMP算法 Rabin-Karp算法 Boyer-Moore算法 图算法：\n拓扑排序 最短路径算法（Dijkstra、Bellman-Ford、Floyd-Warshall） 最小生成树算法（Prim、Kruskal） 更复杂的数据结构： 跳表（Skip List）：用于快速查找的有序数据结构，可以看作是多层链表的结合。 并查集（Union-Find）：一种数据结构，用于处理一些不交集的合并及查询问题。 线段树（Segment Tree）：用于高效解决区间查询和更新问题。 树状数组（Binary Indexed Tree）/斐波那契堆（Fibonacci Heap）：用于高效处理范围查询和动态修改的问题。 Trie（前缀树）：用于高效地存储和检索字符串数据集中的键。 布隆过滤器（Bloom Filter）：一种空间效率极高的数据结构，用于测试一个元素是否属于集合，有可能会出现误判。 LSM树（Log-Structured Merge-Tree）：通常用于键值存储系统中，例如LevelDB和Cassandra。 倒排索引（Inverted Index）：常用于全文搜索引擎，如Elasticsearch和Solr。 高级算法技巧： 分治算法（Divide and Conquer）：将问题分解成若干个小问题递归求解，然后再合并结果。\n动态规划（Dynamic Programming）：\n斐波那契数列 最长公共子序列（LCS） 最长递增子序列（LIS） 0-1背包问题 编辑距离（Levenshtein距离） 贪心算法（Greedy Algorithms）：\n最小生成树（Prim、Kruskal） 哈夫曼编码 回溯算法（Backtracking）：\nN皇后问题 子集和问题 组合问题 分支限界法（Branch and Bound）：\n旅行商问题（TSP） 零一背包问题 启发式算法（Heuristic Algorithms）：\nA*搜索算法 蚁群优化（ACO） 粒子群优化（PSO） 随机化算法（Randomized Algorithms）：\n蒙特卡洛算法 拉斯维加斯算法 跳跃表 近似算法（Approximation Algorithms）：\n用于在多项式时间内找到近似最优解的算法，适用于NP难问题。 流算法（Streaming Algorithms）：\n用于处理大量数据流的算法，通常只需要一次或几次数据遍历。 字符串匹配算法：\n后缀数组 后缀树 正则表达式匹配 查找 通常的，在我们需要进行查找时，使用遍历查找一个一个检查过去便能满足我们的需求，在数据量很小时使用其他的方法甚至会使代码的时间复杂度上升，但当我们处理大数据量时，遍历的效率过于低下，因此我们需要一些特殊的方法进行查找：\n二分查找 二分查找的核心思路是高中数学中的二分法，每次取范围的百分之50，可以快速锁定目标数据所处区间。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 #include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; // 二分查找函数 // 参数： // nums - 有序数组 // target - 要查找的目标值 // 返回值： // 目标值在数组中的索引，如果未找到则返回-1 int binarySearch(const std::vector\u0026lt;int\u0026gt;\u0026amp; nums, int target) { int left = 0; // 查找范围的左边界 int right = nums.size() - 1; // 查找范围的右边界 while (left \u0026lt;= right) { // 当左边界小于等于右边界时继续查找 int mid = left + (right - left) / 2; // 计算中间位置，避免直接相加可能导致的溢出 if (nums[mid] == target) { // 如果中间位置的元素等于目标值，返回中间位置的索引 return mid; } else if (nums[mid] \u0026lt; target) { // 如果中间位置的元素小于目标值，将左边界设置为中间位置加一 // 因为中间位置的元素已经不可能是目标值了，所以可以排除这部分 left = mid + 1; } else { // 如果中间位置的元素大于目标值，将右边界设置为中间位置减一 // 同样，中间位置的元素已经不可能是目标值了，排除这部分 right = mid - 1; } } // 如果循环结束仍未找到目标值，返回-1 return -1; } 简而言之，二分查找的思路如下：首先确定查找范围的边界，然后取中间值并与目标值比较，然后将边界迁移至目标值所在的范围内，重复以下操作，以最终确定目标值的位置。 注：二分查找的前提是所有元素有序排列。\n动态规划(臭名昭著的DP) 差分法 差分法一般用于减小一维数组的运算量，假设这里有一个长度为n的数组a，那么我们建立一个数组diff_a用于记录a[i]与a[i+1]的差值，这个差值本身就是差分。\n例如这里有一个非常长的数组a，我们要在a[x]到ay，我们要对这一堆数据进行相同的操作，例如加减赋值，在这里我们就以加值为例。因为a[i]可以用diff[i-1]到diff[i]+a[1]的累加和表示，所以当我们为diff[i-1]加上一个值后，在a[i]本身与之后所有用差分还原的值均加上了这个值，反之可以在a[i]本身与之后减去这个值。\n利用这一点，我们便可以在diff[x-1]处加上这个值，在diff[y-1]处减去这个值，以完成在a[x]到a[y]处的加值操作。\n以下是洛谷例题示例：\n","date":"2024-11-23T00:00:00Z","image":"http://localhost:1313/images/studying1.jpg","permalink":"http://localhost:1313/p/suanfa/","title":"数据结构算法积累"},{"content":"一.下载vscode 1.打开：https://code.visualstudio.com/download 下载vscode 2.下载后根据引导进行安装（能勾选的都可以勾选上） 3.打开vscode，点击左侧4个正方形组成的图案，在左侧的搜索框中输入chinese，点击install即可将页面改成中文 二.配置vscode 1.打开:https://sourceforge.net/projects/mingw-w64/ 2.不要点击download，点击download下的files，再依次点击Tollchains targetting Win64,Personal Builds,mingw builds,8.1.0,threads posix,最后下载 3.将下载后的文件解压，解压完后点击解压后的文件中的bin，复制这个文件的路径 4.在搜索框中输入环境变量，点击编辑系统环境变量，然后再点击环境变量 5.点击选择path，点击编辑，点击新建，并把刚才复制的路径粘贴进去，再连点3个确定 三.开始写代码 1.打开vscode，再次点击左侧4个正方形组成的图案，搜索c，下载第一个，然后在一个全英文路径的地方创建一个英文文件夹，将其复制到桌面 2.再将其拖至vscode的资源管理器里，然后便可以点击新建文件，并命名，c语言在新建文件名后加.c，c++加.cpp 3.写完代码后按住ctrl+shift+p，在弹出的搜索框里输入c/c++，找到编辑配置UI（Edit Configurations（UI）），点击，再在指定编译器路径中选择我们之前复制的路径，再在下面intellsence模式里选择gcc-x64（legacy）或者gcc-x64 4.再在我们之前下载中文包的地方搜索code runner,下完后右上角会有个三角形，点击，即可运行代码 ___by Boy\n","date":"2024-11-21T00:00:00Z","image":"http://localhost:1313/images/vscode1.png","permalink":"http://localhost:1313/p/vscode/","title":"vscode的c++环境搭建"},{"content":"前言：\n虽然许多人都说c++是最难学的语言，笔者也的确承认这一点，但是笔者认为，c++反而是最能锻炼一个人程序编写能力的语言。c++将内存之类的一般由编译器控制的结构开放给程序员，使其拥有对程序更为慎密操作能力。虽然对大多数初学者来说，其极易出错的各类复杂语法简直就是噩梦，但是当养成了精细控制内存的好习惯后，再去使用其他语言时，则会有一种别样的体验。为什么我早不学这玩意，硬是要去啃c++这反人类的垃圾东西（红温症状），拥有一种别样的舒适感。\n笔记中仅仅记录了些许难点，深点与在经常使用c++进行面向过程编程时容易遗忘的点。（拿c++面向对象写大东西时候用的）\n如果要系统性的学习c++，笔者建议去b站看些黑马程序员的课，笔记作为补充或强调的一部分。\n文件的读写 c++用二进制写入读取文件与普通方法写入读取文件的区别 性能和效率 性能：二进制模式通常比文本模式更快，因为它避免了字符编码和解码的开销，以及格式化和转换的开销。 效率：二进制模式可以更有效地存储数据，因为它不需要额外的空间来存储字符编码，尤其是在处理大型数据集时。 使用场景 文本模式：当你需要处理的是文本数据，并且需要跨平台兼容（比如处理换行符）时，使用文本模式是合适的。 二进制模式：当你需要处理非文本数据，或者需要确保数据的精确二进制表示时（比如图像、音频、视频文件或者自定义的数据结构），使用二进制模式是更合适的。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 #include \u0026lt;iostream\u0026gt; #include \u0026lt;fstream\u0026gt; #include \u0026lt;string\u0026gt; // 定义一个简单的结构体 struct Person { std::string name; int age; }; void writeBinaryFile(const std::string\u0026amp; filename, const Person\u0026amp; person) { std::ofstream ofs(filename, std::ios::binary); // 以二进制模式打开文件 if (!ofs) { std::cerr \u0026lt;\u0026lt; \u0026#34;无法打开文件进行写入\u0026#34; \u0026lt;\u0026lt; std::endl; return; } // 写入数据 ofs.write(person.name.c_str(), person.name.size() + 1); // 写入姓名和终止符 ofs.write(reinterpret_cast\u0026lt;const char*\u0026gt;(\u0026amp;person.age), sizeof(person.age)); // 写入年龄 if (!ofs) { std::cerr \u0026lt;\u0026lt; \u0026#34;写入文件时发生错误\u0026#34; \u0026lt;\u0026lt; std::endl; } ofs.close(); } void readBinaryFile(const std::string\u0026amp; filename, Person\u0026amp; person) { std::ifstream ifs(filename, std::ios::binary); // 以二进制模式打开文件 if (!ifs) { std::cerr \u0026lt;\u0026lt; \u0026#34;无法打开文件进行读取\u0026#34; \u0026lt;\u0026lt; std::endl; return; } // 读取数据 char nameBuffer[100]; // 假设姓名不超过99个字符 ifs.read(nameBuffer, sizeof(nameBuffer) - 1); nameBuffer[ifs.gcount()] = \u0026#39;\\0\u0026#39;; // 确保字符串以null终止 person.name = nameBuffer; ifs.read(reinterpret_cast\u0026lt;char*\u0026gt;(\u0026amp;person.age), sizeof(person.age)); if (!ifs) { std::cerr \u0026lt;\u0026lt; \u0026#34;读取文件时发生错误\u0026#34; \u0026lt;\u0026lt; std::endl; } ifs.close(); } int main() { Person personToWrite = {\u0026#34;John Doe\u0026#34;, 30}; Person personToRead; writeBinaryFile(\u0026#34;person.dat\u0026#34;, personToWrite); // 写入文件 readBinaryFile(\u0026#34;person.dat\u0026#34;, personToRead); // 读取文件 std::cout \u0026lt;\u0026lt; \u0026#34;姓名: \u0026#34; \u0026lt;\u0026lt; personToRead.name \u0026lt;\u0026lt; \u0026#34;, 年龄: \u0026#34; \u0026lt;\u0026lt; personToRead.age \u0026lt;\u0026lt; std::endl; return 0; } 读取文件的四种基本方法 1 2 3 4 char arr[1000]= {0}; while(ifs\u0026gt;\u0026gt;arr) { cout \u0026lt;\u0026lt; arr \u0026lt;\u0026lt; endl; } 1 2 3 4 char arr[1000]= {0}; while(ifs.getline(arr,sizeof(arr))) { cout \u0026lt;\u0026lt; arr \u0026lt;\u0026lt; endl; }//ifstream的ifs.getline需输入变量名与容量 1 2 3 4 5 #include\u0026lt;string\u0026gt; string line; while(getline(ifs,line)) { cout \u0026lt;\u0026lt; line \u0026lt;\u0026lt; endl; }//使用iostream自带的getline需输入数据流类型与变量名 1 2 3 4 char c; while((c = ifs.get()) != EOF) {//EOF是文件尾的意思（end of file） cout \u0026lt;\u0026lt; c; }//ifs.get每次读取一个字符 处理大量数据时的读取方法效率比较 处理大量数据时，选择最有效的读取方法取决于数据的特性和程序的需求。以下是对四种读取方法的效率比较：\n使用 \u0026raquo; 操作符：\n效率：较低 原因：\u0026gt;\u0026gt; 操作符会跳过空白字符（如空格、制表符和换行符），只读取直到下一个空白字符之前的字符串。如果数据中包含大量的空白字符，这种方法会导致频繁的读取操作，效率较低。 使用 ifs.getline(arr, sizeof(arr))：\n效率：中等 原因：getline 函数读取整行数据，直到遇到换行符或达到缓冲区大小。这种方法适用于读取固定长度的行，但如果行长度不一，可能会导致不必要的内存拷贝和缓冲区溢出。 使用 string 和 getline(ifs, line)：\n效率：较高 原因：这种方法使用 string 类型的变量来存储每行数据，getline 函数会自动管理内存，只分配所需的空间。这种方法对于处理长度不一的行数据非常有效，因为它可以动态调整内存分配。 使用 ifs.get(c)：\n效率：最低 原因：get 函数每次只读取一个字符，这对于处理大量数据来说是非常低效的，因为它涉及到大量的函数调用和可能的内存访问。 结论 如果输入流中的数据量非常大，且每行的长度大致相同，使用 ifs.getline(arr, sizeof(arr)) 方法可能更有效，因为它可以一次性读取整行数据，减少了函数调用的次数。 如果输入流中的数据量非常大，且每行的长度不一，使用 string 和 getline(ifs, line) 方法可能更有效，因为 string 类型可以动态管理内存，适应不同长度的行数据。 在处理大量数据时，还应该考虑其他因素，如内存使用、CPU缓存效率和I/O操作的开销。通常，减少I/O操作的次数和优化内存使用可以提高程序的整体效率。\ncmd控制台读取文件乱码解决方案 将当前文本文件另存为在当前目录下，将之前那个覆盖即可。\nc++文件读写操作基础语法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 #include \u0026lt;iostream\u0026gt; #include \u0026lt;fstream\u0026gt; using namespace std; void test01() { ofstream ofs; ofs.open(\u0026#34;test.txt\u0026#34;,ios::out); ofs\u0026lt;\u0026lt;\u0026#34;张三\u0026#34;\u0026lt;\u0026lt;endl; ofs\u0026lt;\u0026lt;\u0026#34;李四\u0026#34;\u0026lt;\u0026lt;endl; ofs\u0026lt;\u0026lt;\u0026#34;王五\u0026#34;\u0026lt;\u0026lt;endl; ofs.close(); } int main() { test01(); } 1.若需对文件进行读写操作，需先包含库(文件操作流库)，基础语法如下：\n1 2 3 4 5 6 7 8 9 10 #include \u0026lt;fstream\u0026gt; void del_file(const std::string\u0026amp; filename) { std::ofstream file(filename, std::ios::out | std::ios::trunc); if (file.is_open()) { file.close(); // 打开文件并立即关闭，这将清空文件内容 } else { std::cerr \u0026lt;\u0026lt; \u0026#34;Unable to open file \u0026#34; \u0026lt;\u0026lt; filename \u0026lt;\u0026lt; std::endl; } } 难点语法 构造函数基本原则 与类名相同，没有返回类型（包括void）。 可以有参数，用于给对象的数据成员赋初值。 可以重载，可以有多个构造函数，根据参数的不同进行区分。 默认构造函数是没有参数的构造函数，如果没有定义任何构造函数，C++会自动提供一个默认构造函数，默认构造函数不做任何操作。 构造函数可以被显式地调用，也可以被隐式地调用。 调用原则：\n对象创建时自动调用：\n构造函数在创建对象时自动被调用，无需手动调用。\n构造函数重载匹配：\n如果类定义了多个构造函数，编译器会根据传递的参数来匹配合适的构造函数进行调用。\n默认构造函数的调用：\n如果没有显式定义构造函数，编译器会提供一个默认构造函数，用于创建对象并将成员变量初始化为默认值。\n显式调用构造函数：\n可以显式地调用构造函数来创建对象，即使用类名后跟括号和参数列表的形式进行调用。\n初始化列表的使用：\n构造函数可以使用初始化列表来初始化成员变量，这样可以更高效地初始化对象的数据成员。初始化列表位于构造函数的函数体之前。\n基类构造函数的调用：\n派生类的构造函数会自动调用基类的构造函数来初始化继承的成员。可以使用初始化列表来指定基类构造函数的参数。\n析构函数的调用：\n析构函数在对象被销毁时自动调用，用于执行清理工作，例如释放动态分配的内存或关闭打开的文件。\n指针基本语法 int a = 0\n//声明指针\nint * p;\n//记录地址\np = \u0026amp;a\n//使用指针\n*p = 10000\n*cout\u0026laquo;p\u0026laquo;;\nint *p = nullptr(空指针，用于给指针清空)\n野指针指指向地址非法的指针\nconst 在 int * 前时构成常量指针，常量指针是指指针指向的值不能改变，但可以改变指针的指向。\nconst在 int * 后时构成指针常量， 指针常量指向的量不能改变，但量的值能够改变\nconst在int * 前后都有时构成常量指针常量，他指向的值与值本身都不能改变\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 #include\u0026lt;iostream\u0026gt; using namespace std; // 定义一个名为myclass的类 class myclass { public: int age; // 类的成员变量，用于存储年龄 // 类的构造函数，用于初始化对象的age成员变量 myclass(int age) { this-\u0026gt;age = age; // 将传入的age值赋给对象的age成员变量 } // 类的成员函数，用于将传入对象的age值加到当前对象的age上，并返回当前对象的引用 myclass\u0026amp; numadd(myclass \u0026amp;p) { this-\u0026gt;age += p.age; // 将传入对象的age值加到当前对象的age上 return *this; // 返回当前对象的引用，这样可以进行链式调用 } }; int main() { // 创建一个myclass类型的对象p1，并初始化其age为10 myclass p1(10); // 使用p1对象创建另一个myclass类型的对象p2 myclass p2(p1); // 使用链式编程思想，将p1对象的age值连续三次加到p2对象的age上 p2.numadd(p1).numadd(p1).numadd(p1); // 输出p2对象的age值 cout \u0026lt;\u0026lt; p2.age; } *this 指代当前对象的引用\nthis-\u0026gt;指针指代当前类中的成员变量\n空指针也可以访问成员函数\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 #include\u0026lt;iostream\u0026gt; using namespace std; class myclass { public: int age; void print() { cout \u0026lt;\u0026lt; \u0026#34;this is null.\u0026#34;; } }; int main(){ myclass* null = NULL; null-\u0026gt;print(); } 但当成员函数中存在成员变量的调用时，空指针指向的成员函数会报错.\n析构函数的特例\n当一个对象被销毁时，如果它的析构函数被调用，并且这个对象是通过空指针访问的，C++运行时会允许这次调用。这是因为析构函数的调用是为了释放资源，即使对象已经被销毁，析构函数也需要能够执行。这个特例只在析构函数中有效，并且仅限于对象的销毁过程。\n动态数组自动扩容 int* arr = new int[初始大小]\nif(数组存满){\nint arrNew = new int[原容量 * 2]\nfor(int a = 0;a\u0026lt;原容量;a++)\n{\narrNew[a] = arr[a];\n} //用于转移数组内存储数据 delete[] arr; //用于释放原有数组内存\narr = arrNew; //用于重新指向arr指针位置\n面向对象 类继承示例与说明 类定义与继承 1 2 class DadClass {}; class SonClass : public DadClass {}; SonClass 通过 public 继承自 DadClass，这意味着 SonClass 将继承 DadClass 的所有 public 和 protected 成员。 成员继承与访问权限 Public 继承：将父类的 public 和 protected 成员继承为子类的 public 和 protected 成员（private 成员不可访问）。 Protected 继承：将父类的 public 和 protected 成员继承为子类的 protected 成员。 Private 继承：将父类的 public 和 protected 成员继承为子类的 private 成员。 构造函数与析构函数的调用顺序 当创建子类对象时，首先调用父类的构造函数，然后调用子类的构造函数。 当销毁子类对象时，首先调用子类的析构函数，然后调用父类的析构函数。 成员隐藏与访问 当子类与父类有同名成员时，子类成员会隐藏父类成员。要访问被隐藏的父类成员，需要使用作用域解析运算符（::）。\n示例代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; using namespace std; class FatherClass { public: string name; FatherClass() : name(\u0026#34;Here is FatherClass\u0026#34;) {} }; class SonClass : public FatherClass { public: string name; SonClass() : name(\u0026#34;Here is SonClass\u0026#34;) {} }; void test01() { FatherClass f1; SonClass s1; cout \u0026lt;\u0026lt; \u0026#34;f1.name = \u0026#34; \u0026lt;\u0026lt; f1.name \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;s1.name = \u0026#34; \u0026lt;\u0026lt; s1.name \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;s1\u0026#39;s FatherClass::name = \u0026#34; \u0026lt;\u0026lt; s1.FatherClass::name \u0026lt;\u0026lt; endl; } int main() { test01(); // system(\u0026#34;pause\u0026#34;); // 通常在非Windows系统上不需要此行 return 0; } 多重继承与菱形继承 C++ 支持多重继承，但如果多个父类有同名成员，访问时需要指定作用域。菱形继承可能导致二义性，为避免这种情况，可以使用虚继承。\n菱形继承示例 1 2 3 class AnotherClass {}; class SonClass2 : virtual public FatherClass, public AnotherClass {}; 在菱形继承中，SonClass2 通过虚继承从 FatherClass 继承，以避免由于 FatherClass 被多次继承而导致的成员变量重复定义问题。\n虚析构函数 当子类在堆上分配内存时，如果父类的析构函数不是虚函数，那么删除子类对象时不会调用子类的析构函数，从而导致内存泄漏。为避免这种情况，应将父类的析构函数声明为虚函数。\n1 2 3 4 class Base { public: virtual ~Base() {} // 虚析构函数 }; 如果希望父类成为抽象类，可以将析构函数声明为纯虚函数，但需要在类外提供实现。\n1 2 3 4 5 6 class AbstractBase { public: virtual ~AbstractBase() = 0; // 纯虚析构函数声明 }; AbstractBase::~AbstractBase() {} // 纯虚析构函数实现 多态性与虚函数 虚函数的定义和工作原理 在父类中的引用函数想要在子类中顺利调用，可以将函数定义为虚函数。\n虚函数表（VTable） 每个包含虚函数的类都有一个虚函数表（VTable），这是一个函数指针数组。 这个表在类的构造函数中被初始化，包含了指向该类中所有虚函数的指针。 虚函数指针（VPtr） 每个包含虚函数的对象都有一个虚函数表指针（VPtr），它指向该对象所属类的虚函数表。 当创建一个对象时，构造函数会设置这个指针，使其指向正确的虚函数表。 函数调用 当通过对象调用一个虚函数时，编译器不会直接调用该函数，而是通过虚函数表指针查找对应的函数指针，然后调用该指针指向的函数。 这意味着，即使通过基类的指针或引用调用虚函数，只要对象的实际类型是派生类，就会调用派生类中重写的函数。 示例代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 #include\u0026lt;iostream\u0026gt; #include\u0026lt;string\u0026gt; using namespace std; class father { public: father(): name(\u0026#34;Dad\u0026#34;) {} string name; virtual void printfatherclass(father\u0026amp; who) { cout \u0026lt;\u0026lt; \u0026#34;here is class\u0026#39;s name: \u0026#34; \u0026lt;\u0026lt; who.name \u0026lt;\u0026lt; endl; } }; class son: public father { public: son() { name = \u0026#34;Son\u0026#34;; } }; void test01() { father a; a.printfatherclass(a); son b; b.printfatherclass(b); } int main() { test01(); system(\u0026#34;pause\u0026#34;); return 0; } 判断、函数运算符重载与继承基础语法示例 以下是一个C++程序，展示了如何进行判断、函数运算符重载以及继承的基础语法。\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 #include \u0026lt;iostream\u0026gt; using namespace std; class myclass { public: bool operator==(myclass\u0026amp; p) { if(this-\u0026gt;m_h == p.m_h \u0026amp;\u0026amp; this-\u0026gt;m_w == p.m_w) { return true; } else { return false; } } bool operator!=(const myclass\u0026amp; p) { if(this-\u0026gt;m_h == p.m_h \u0026amp;\u0026amp; this-\u0026gt;m_w == p.m_w) { return false; } else { return true; } } bool operator\u0026gt;(const myclass\u0026amp; p) { if(this-\u0026gt;m_h \u0026gt; p.m_h \u0026amp;\u0026amp; this-\u0026gt;m_w \u0026gt; p.m_w) { return true; } else { return false; } } myclass(int num1, int num2) : m_h(176), m_w(75) { m_h = num1; m_w = num2; } myclass() : m_h(176), m_w(75) {} private: int m_h; int m_w; }; class AddNum { public: int operator()(int num1, int num2) { return num1 + num2; } }; void test01() { myclass p1; myclass p2(160, 45); if(p1 == p2) { cout \u0026lt;\u0026lt; \u0026#34;true\u0026#34; \u0026lt;\u0026lt; endl; } else { cout \u0026lt;\u0026lt; \u0026#34;false\u0026#34; \u0026lt;\u0026lt; endl; } cout \u0026lt;\u0026lt; AddNum()(10, 20) \u0026lt;\u0026lt; endl; } class basetxt { public: void lefttxt() { cout \u0026lt;\u0026lt; \u0026#34;here is left txt\u0026#34; \u0026lt;\u0026lt; endl; } void toptxt() { cout \u0026lt;\u0026lt; \u0026#34;here is top txt\u0026#34; \u0026lt;\u0026lt; endl; } void righttxt() { cout \u0026lt;\u0026lt; \u0026#34;here is right txt\u0026#34; \u0026lt;\u0026lt; endl; } void lesttxt() { cout \u0026lt;\u0026lt; \u0026#34;here is lest txt\u0026#34; \u0026lt;\u0026lt; endl; } }; class page1txt : public basetxt { public: void pagetxt() { cout \u0026lt;\u0026lt; \u0026#34;here is page1 txt\u0026#34; \u0026lt;\u0026lt; endl; } }; class page2txt : public basetxt { public: void pagetxt() { cout \u0026lt;\u0026lt; \u0026#34;here is page2 txt\u0026#34; \u0026lt;\u0026lt; endl; } }; class page3txt : public basetxt { public: void pagetxt() { cout \u0026lt;\u0026lt; \u0026#34;here is page3 txt\u0026#34; \u0026lt;\u0026lt; endl; } }; class page4txt : public basetxt { public: void pagetxt() { cout \u0026lt;\u0026lt; \u0026#34;here is page4 txt\u0026#34; \u0026lt;\u0026lt; endl; } }; void test02() { page1txt().lefttxt(); page1txt().toptxt(); page1txt().righttxt(); page1txt().lesttxt(); page1txt().pagetxt(); cout \u0026lt;\u0026lt; \u0026#34;--------------------\u0026#34; \u0026lt;\u0026lt; endl; page2txt().lefttxt(); page2txt().toptxt(); page2txt().righttxt(); page2txt().lesttxt(); page2txt().pagetxt(); cout \u0026lt;\u0026lt; \u0026#34;--------------------\u0026#34; \u0026lt;\u0026lt; endl; page3txt().lefttxt(); page3txt().toptxt(); page3txt().righttxt(); page3txt().lesttxt(); page3txt().pagetxt(); cout \u0026lt;\u0026lt; \u0026#34;--------------------\u0026#34; \u0026lt;\u0026lt; endl; page4txt().lefttxt(); page4txt().toptxt(); page4txt().righttxt(); page4txt().lesttxt(); page4txt().pagetxt(); cout \u0026lt;\u0026lt; \u0026#34;--------------------\u0026#34; \u0026lt;\u0026lt; endl; } int main() { test01(); cout \u0026lt;\u0026lt; endl; test02(); system(\u0026#34;pause\u0026#34;); } 运算符重载 运算符重载一般用于自定义类之间的运算，可以简化代码，提高代码可读性。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 #include\u0026lt;iostream\u0026gt; using namespace std; class myclass { public: int m_a; int m_b; // 类的构造函数，初始化成员变量m_a和m_b为10 myclass() :m_a(10), m_b(10) {} // 重载+运算符，使其能够用于myclass类型的对象 // 这个函数接受一个myclass类型的对象作为参数，并返回一个新的myclass对象 myclass operator+(myclass\u0026amp; p) { myclass temp; // 创建一个临时的myclass对象，用于存储运算结果 // 将当前对象的m_a与传入对象的m_a相加，结果赋值给临时对象的m_a temp.m_a = this-\u0026gt;m_a + p.m_a; // 将当前对象的m_b与传入对象的m_b相加，结果赋值给临时对象的m_b temp.m_b = this-\u0026gt;m_b + p.m_b; return temp; // 返回临时对象，作为+运算符的结果 } }; int main() { myclass p1; myclass p2; myclass p3; // 使用重载的+运算符，将p1和p2相加，结果赋值给p3 p3 = p1 + p2; cout \u0026lt;\u0026lt; \u0026#34;p3.m_a = \u0026#34; \u0026lt;\u0026lt; p3.m_a \u0026lt;\u0026lt; endl \u0026lt;\u0026lt; \u0026#34;p3.m_b = \u0026#34; \u0026lt;\u0026lt; p3.m_b \u0026lt;\u0026lt; endl; } // 声明一个重载的左移运算符（\u0026lt;\u0026lt;）函数，用于将myclass类的对象信息输出到ostream类型的流中 ostream\u0026amp; operator\u0026lt;\u0026lt;(ostream\u0026amp; cout, myclass\u0026amp; p) { // 使用传入的ostream引用（在这个上下文中通常是cout），输出myclass对象的m_a成员变量的值 cout \u0026lt;\u0026lt; \u0026#34;m_a = \u0026#34; \u0026lt;\u0026lt; p.m_a; // 输出一个换行符，以便将m_a和m_b的输出分开，增加输出的可读性 cout \u0026lt;\u0026lt; endl; // 继续使用cout输出myclass对象的m_b成员变量的值，并在值后面添加一个换行符 cout \u0026lt;\u0026lt; \u0026#34;m_b = \u0026#34; \u0026lt;\u0026lt; p.m_b \u0026lt;\u0026lt; endl; // 返回传入的ostream引用，这里通常是cout，这样函数就可以支持连续的输出操作（链式调用） return cout; } 解释 类定义：myclass 类有两个成员变量 m_a 和 m_b，并通过构造函数初始化为 10。 运算符重载： operator+：重载了加法运算符，使两个 myclass 对象可以相加。返回一个新的 myclass 对象，其成员变量是两个相加对象的对应成员变量的和。 main 函数：创建三个 myclass 对象 p1、p2 和 p3，使用重载的 + 运算符将 p1 和 p2 相加，并将结果赋给 p3，最后输出 p3 的成员变量值。 输出运算符重载：重载了 \u0026lt;\u0026lt; 运算符，使 myclass 对象可以直接输出到标准输出流 cout。 通过这种方式，自定义类的对象可以像基本数据类型一样进行运算和输出，提高了代码的可读性和易用性。\n注意事项 运算符重载不会改变运算符的优先级和结合性。 运算符重载函数可以是成员函数，也可以是友元函数或非成员函数，但一般成员函数和友元函数更为常见。 对于一些非成员函数运算符重载，可能需要将相关的类声明为友元类，以便访问类的私有或受保护成员。 总结 运算符重载是 C++ 中的一个强大特性，允许开发者为自定义类型定义标准运算符的行为。通过重载运算符，可以使自定义类型的使用更加直观和方便。\n全局函数友元 当在类（class）中声明友元（friend）函数后，便可以在全局函数中调用私有对象，示例如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 #include\u0026lt;iostream\u0026gt; using namespace std; class myclass { public: friend void test01(myclass* Myclass); myclass():age(18),weight(70) { } int age; private: int weight; }; void test01(myclass* Myclass) { cout \u0026lt;\u0026lt; \u0026#34;正在访问“age”\u0026#34; \u0026lt;\u0026lt; endl \u0026lt;\u0026lt; \u0026#34;age = \u0026#34; \u0026lt;\u0026lt; Myclass-\u0026gt;age\u0026lt;\u0026lt;endl; cout \u0026lt;\u0026lt; \u0026#34;正在访问“weight”\u0026#34; \u0026lt;\u0026lt; endl \u0026lt;\u0026lt; \u0026#34;age = \u0026#34; \u0026lt;\u0026lt; Myclass-\u0026gt;weight; } int main(){ myclass p1; test01(\u0026amp;p1);//在调用使用指针传输的函数时，传入的数据应为对象的地址或指针 } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 #include\u0026lt;iostream\u0026gt; using namespace std; class myclass { public: friend void test01(myclass\u0026amp; Myclass); myclass():age(18),weight(70) { } int age; private: int weight; }; void test01(myclass\u0026amp; Myclass) { cout \u0026lt;\u0026lt; \u0026#34;正在访问“age”\u0026#34; \u0026lt;\u0026lt; endl \u0026lt;\u0026lt; \u0026#34;age = \u0026#34; \u0026lt;\u0026lt; Myclass.age\u0026lt;\u0026lt;endl; cout \u0026lt;\u0026lt; \u0026#34;正在访问“weight”\u0026#34; \u0026lt;\u0026lt; endl \u0026lt;\u0026lt; \u0026#34;age = \u0026#34; \u0026lt;\u0026lt; Myclass.weight; } int main(){ myclass p1; test01(p1);//在调用使用引用传输的函数时，传入的数据应为对象本身 } 当成员函数访问其他类中私有成员时，应如此声明：\nfriend class01(成员函数所属的类)::void class01test ;\nSTL容器（简略写点） 基本语法 创建容器： vector \u0026lt;数据类型\u0026gt; 容器名 {数组内容};\n使用迭代器:vector\u0026lt;数据类型\u0026gt;::iterators 地址名（类似于指针）= 取址函数 *元素的选取：地址名 || 容器名.at(元素的序号) || 容器名[元素的序号]\n取址函数（函数名之前加c会成为只读型）:\nbegin() 指向容器的第一个元素 end() 指向元素的最后一个元素的后一位 rbegin() 倒序指向的begin() rend() 倒序指向的end() 容量函数：\nsize() 容器内元素的个数 empty() 若容器为空则返回true，否则返回false reserve() 为容器预留不可访问的空间，减少容器追加空间的次数，降低运算复杂度（增大内存占用） 修改函数：\npush_back 在容器尾追加元素 pop_back 删除最后一个元素 insert 插入元素 erase 删除元素 clear 清空容器 swap 交换元素位置 assign 替换元素 emplace 更快的插入 emplace_back 更快的追加元素 各种容器之间的用途与区别：\nlist ：双向链表，可以快速的插入与删除某一元素，遍历和空间占用差\nvector ：动态指针，可以自动扩容，遍历最快\ndeque ：可以在头尾分别操作元素，但是速度慢于vector\nstack ：类似于羽毛球筒，只能调用和访问最顶上的数据，数据存储在栈区\nqueue ：类似于队伍，只能访问两端元素，不可遍历，只能向一端插入一端删除。\nset与multiset ：数组，可以遍历，会自动排序，前者元素不可重复，后者可以.\nSTL容器的一些示例 大数阶乘（容器） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 #include \u0026lt;iostream\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;vector\u0026gt; using namespace std; void print(int val) { cout \u0026lt;\u0026lt; val; } int main() { int temp1; int temp2 = 0; int n; cout \u0026lt;\u0026lt; \u0026#34;请输入n： \u0026#34;; cin \u0026gt;\u0026gt; n; vector\u0026lt;int\u0026gt; v1; v1.push_back(1); for (int i = 1; i \u0026lt;= n; i++) { for (int j = 0; j \u0026lt; v1.size(); j++) { v1.at(j) = v1.at(j)*i + temp2; temp2 = v1.at(j)/10; v1.at(j) = v1.at(j)%10; } while (temp2 \u0026gt; 0) { v1.push_back(temp2%10); temp2 = temp2/10; } } for (int i = v1.size()-1;i\u0026gt;=0; i--) { print(v1.at(i)); } system(\u0026#34;pause\u0026#34;); } 基于vector容器的素数查找 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 #include \u0026lt;iostream\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;vector\u0026gt; using namespace std; void test01(int n) { vector\u0026lt;int\u0026gt; v; int flag = 0; int times = 0; for (int i = 1; i \u0026lt; n+1; i++) { vector\u0026lt;int\u0026gt;::iterator it = v.begin(); while(it != v.end()) { if(i % *it == 0) { flag = 1; } it++; } if(flag == 0) { if(i != 1) { v.push_back(i); } cout\u0026lt;\u0026lt;\u0026#34; \u0026#34;\u0026lt;\u0026lt;i; times++; } if(times == 4) { cout\u0026lt;\u0026lt;endl; times = 0; } flag = 0; } } int main() {int times; cout\u0026lt;\u0026lt;\u0026#34;请输入你所需要查找的素数范围（0~n）：\u0026#34;\u0026lt;\u0026lt;endl; cin\u0026gt;\u0026gt;times; test01(times); system(\u0026#34;pause\u0026#34;); } ","date":"2024-11-04T00:00:00Z","image":"http://localhost:1313/images/code1.jpg","permalink":"http://localhost:1313/p/c-/","title":"C++语法笔记"},{"content":"准备阶段 首先，先准备一份客户端，确保你与你的朋友的客户端版本以及mod相同。\n实现远程联机 步骤1：搜索樱花穿透 我们将基于内网穿透来实现远程联机。请在百度搜索“樱花穿透”，访问官方网站：Sakura Frp。\n步骤2：注册并登录 在樱花穿透官方网站注册账号并登录。 步骤3：下载樱花穿透应用程序 下载并安装樱花穿透应用程序。 步骤4：签到获取流量 在管理面板首页签到，以获取免费流量。 步骤5：获取授权码 在管理面板首页获取授权码。 步骤6：使用授权码登录 在樱花穿透应用程序上使用授权码登录。 步骤7：创建端口 创建端口，选择TCP，下面设置改成“我的世界”。 步骤8：完成设置 完成以上设置后，打开游戏，打开局域网链接（如果朋友使用盗版登录链接，请主机先下载联机mod，选择关闭正版验证）。\n步骤9：分享端口码 复制樱花穿透应用程序中给出的端口码，发送给你的朋友让他输入到直接连接中，点击确定。 结果 现在你成功实现用简单的内网穿透远程联机了！\n","date":"2024-11-04T00:00:00Z","image":"http://localhost:1313/images/plc.png","permalink":"http://localhost:1313/p/wdsj/","title":"我的世界JAVA版非局域网远程联机教程"},{"content":"","date":"0001-01-01T00:00:00Z","permalink":"http://localhost:1313/p/","title":""},{"content":"","date":"0001-01-01T00:00:00Z","permalink":"http://localhost:1313/p/","title":""},{"content":"","date":"0001-01-01T00:00:00Z","permalink":"http://localhost:1313/p/","title":""}]