[{"content":"难点语法 构造函数基本原则 与类名相同，没有返回类型（包括void）。 可以有参数，用于给对象的数据成员赋初值。 可以重载，可以有多个构造函数，根据参数的不同进行区分。 默认构造函数是没有参数的构造函数，如果没有定义任何构造函数，C++会自动提供一个默认构造函数，默认构造函数不做任何操作。 构造函数可以被显式地调用，也可以被隐式地调用。 调用原则：\n对象创建时自动调用：\n构造函数在创建对象时自动被调用，无需手动调用。\n构造函数重载匹配：\n如果类定义了多个构造函数，编译器会根据传递的参数来匹配合适的构造函数进行调用。\n默认构造函数的调用：\n如果没有显式定义构造函数，编译器会提供一个默认构造函数，用于创建对象并将成员变量初始化为默认值。\n显式调用构造函数：\n可以显式地调用构造函数来创建对象，即使用类名后跟括号和参数列表的形式进行调用。\n初始化列表的使用：\n构造函数可以使用初始化列表来初始化成员变量，这样可以更高效地初始化对象的数据成员。初始化列表位于构造函数的函数体之前。\n基类构造函数的调用：\n派生类的构造函数会自动调用基类的构造函数来初始化继承的成员。可以使用初始化列表来指定基类构造函数的参数。\n析构函数的调用：\n析构函数在对象被销毁时自动调用，用于执行清理工作，例如释放动态分配的内存或关闭打开的文件。\nint a = 0\n//声明指针\nint * p;\n//记录地址\np = \u0026amp;a**\u0026lt;font style=\u0026quot;background-color:rgb(255, 250, 165);\u0026quot;\u0026gt;\u0026lt;/font\u0026gt;**\n//使用指针\n*p = 10000\n*cout\u0026laquo;p\u0026laquo;;\nint *p = nullptr(空指针，用于给指针清空)\n野指针指指向地址非法的指针\nconst 在 int * 前时构成常量指针，常量指针是指指针指向的值不能改变，但可以改变指针的指向。\nconst在 int * 后时构成指针常量， 指针常量指向的量不能改变，但量的值能够改变\nconst在int * 前后都有时构成常量指针常量，他指向的值与值本身都不能改变\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 #include\u0026lt;iostream\u0026gt; using namespace std; // 定义一个名为myclass的类 class myclass { public: int age; // 类的成员变量，用于存储年龄 // 类的构造函数，用于初始化对象的age成员变量 myclass(int age) { this-\u0026gt;age = age; // 将传入的age值赋给对象的age成员变量 } // 类的成员函数，用于将传入对象的age值加到当前对象的age上，并返回当前对象的引用 myclass\u0026amp; numadd(myclass \u0026amp;p) { this-\u0026gt;age += p.age; // 将传入对象的age值加到当前对象的age上 return *this; // 返回当前对象的引用，这样可以进行链式调用 } }; int main() { // 创建一个myclass类型的对象p1，并初始化其age为10 myclass p1(10); // 使用p1对象创建另一个myclass类型的对象p2 myclass p2(p1); // 使用链式编程思想，将p1对象的age值连续三次加到p2对象的age上 p2.numadd(p1).numadd(p1).numadd(p1); // 输出p2对象的age值 cout \u0026lt;\u0026lt; p2.age; } *this 指代当前对象的引用\nthis-\u0026gt;指针指代当前类中的成员变量\n空指针也可以访问成员函数\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 #include\u0026lt;iostream\u0026gt; using namespace std; class myclass { public: int age; void print() { cout \u0026lt;\u0026lt; \u0026#34;this is null.\u0026#34;; } }; int main(){ myclass* null = NULL; null-\u0026gt;print(); } 但当成员函数中存在成员变量的调用时，空指针指向的成员函数会报错.\n析构函数的特例\n当一个对象被销毁时，如果它的析构函数被调用，并且这个对象是通过空指针访问的，C++运行时会允许这次调用。这是因为析构函数的调用是为了释放资源，即使对象已经被销毁，析构函数也需要能够执行。这个特例只在析构函数中有效，并且仅限于对象的销毁过程。\n动态数组自动扩容 int* arr = new int[初始大小]\nif(数组存满){\nint arrNew = new int[原容量 * 2]\nfor(int a = 0;a\u0026lt;原容量;a++)\n{\narrNew[a] = arr[a];\n} //用于转移数组内存储数据 delete[] arr; //用于释放原有数组内存\narr = arrNew; //用于重新指向arr指针位置\n面向对象 类继承示例与说明 类定义与继承 1 2 class DadClass {}; class SonClass : public DadClass {}; SonClass 通过 public 继承自 DadClass，这意味着 SonClass 将继承 DadClass 的所有 public 和 protected 成员。 成员继承与访问权限 Public 继承：将父类的 public 和 protected 成员继承为子类的 public 和 protected 成员（private 成员不可访问）。 Protected 继承：将父类的 public 和 protected 成员继承为子类的 protected 成员。 Private 继承：将父类的 public 和 protected 成员继承为子类的 private 成员。 构造函数与析构函数的调用顺序 当创建子类对象时，首先调用父类的构造函数，然后调用子类的构造函数。 当销毁子类对象时，首先调用子类的析构函数，然后调用父类的析构函数。 成员隐藏与访问 当子类与父类有同名成员时，子类成员会隐藏父类成员。要访问被隐藏的父类成员，需要使用作用域解析运算符（::）。\n示例代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; using namespace std; class FatherClass { public: string name; FatherClass() : name(\u0026#34;Here is FatherClass\u0026#34;) {} }; class SonClass : public FatherClass { public: string name; SonClass() : name(\u0026#34;Here is SonClass\u0026#34;) {} }; void test01() { FatherClass f1; SonClass s1; cout \u0026lt;\u0026lt; \u0026#34;f1.name = \u0026#34; \u0026lt;\u0026lt; f1.name \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;s1.name = \u0026#34; \u0026lt;\u0026lt; s1.name \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;s1\u0026#39;s FatherClass::name = \u0026#34; \u0026lt;\u0026lt; s1.FatherClass::name \u0026lt;\u0026lt; endl; } int main() { test01(); // system(\u0026#34;pause\u0026#34;); // 通常在非Windows系统上不需要此行 return 0; } 多重继承与菱形继承 C++ 支持多重继承，但如果多个父类有同名成员，访问时需要指定作用域。菱形继承可能导致二义性，为避免这种情况，可以使用虚继承。\n菱形继承示例 1 2 3 class AnotherClass {}; class SonClass2 : virtual public FatherClass, public AnotherClass {}; 在菱形继承中，SonClass2 通过虚继承从 FatherClass 继承，以避免由于 FatherClass 被多次继承而导致的成员变量重复定义问题。\n虚析构函数 当子类在堆上分配内存时，如果父类的析构函数不是虚函数，那么删除子类对象时不会调用子类的析构函数，从而导致内存泄漏。为避免这种情况，应将父类的析构函数声明为虚函数。\n1 2 3 4 class Base { public: virtual ~Base() {} // 虚析构函数 }; 如果希望父类成为抽象类，可以将析构函数声明为纯虚函数，但需要在类外提供实现。\n1 2 3 4 5 6 class AbstractBase { public: virtual ~AbstractBase() = 0; // 纯虚析构函数声明 }; AbstractBase::~AbstractBase() {} // 纯虚析构函数实现 多态性与虚函数 虚函数的定义和工作原理 在父类中的引用函数想要在子类中顺利调用，可以将函数定义为虚函数。\n虚函数表（VTable） 每个包含虚函数的类都有一个虚函数表（VTable），这是一个函数指针数组。 这个表在类的构造函数中被初始化，包含了指向该类中所有虚函数的指针。 虚函数指针（VPtr） 每个包含虚函数的对象都有一个虚函数表指针（VPtr），它指向该对象所属类的虚函数表。 当创建一个对象时，构造函数会设置这个指针，使其指向正确的虚函数表。 函数调用 当通过对象调用一个虚函数时，编译器不会直接调用该函数，而是通过虚函数表指针查找对应的函数指针，然后调用该指针指向的函数。 这意味着，即使通过基类的指针或引用调用虚函数，只要对象的实际类型是派生类，就会调用派生类中重写的函数。 示例代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 #include\u0026lt;iostream\u0026gt; #include\u0026lt;string\u0026gt; using namespace std; class father { public: father(): name(\u0026#34;Dad\u0026#34;) {} string name; virtual void printfatherclass(father\u0026amp; who) { cout \u0026lt;\u0026lt; \u0026#34;here is class\u0026#39;s name: \u0026#34; \u0026lt;\u0026lt; who.name \u0026lt;\u0026lt; endl; } }; class son: public father { public: son() { name = \u0026#34;Son\u0026#34;; } }; void test01() { father a; a.printfatherclass(a); son b; b.printfatherclass(b); } int main() { test01(); system(\u0026#34;pause\u0026#34;); return 0; } 判断、函数运算符重载与继承基础语法示例 以下是一个C++程序，展示了如何进行判断、函数运算符重载以及继承的基础语法。\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 #include \u0026lt;iostream\u0026gt; using namespace std; class myclass { public: bool operator==(myclass\u0026amp; p) { if(this-\u0026gt;m_h == p.m_h \u0026amp;\u0026amp; this-\u0026gt;m_w == p.m_w) { return true; } else { return false; } } bool operator!=(const myclass\u0026amp; p) { if(this-\u0026gt;m_h == p.m_h \u0026amp;\u0026amp; this-\u0026gt;m_w == p.m_w) { return false; } else { return true; } } bool operator\u0026gt;(const myclass\u0026amp; p) { if(this-\u0026gt;m_h \u0026gt; p.m_h \u0026amp;\u0026amp; this-\u0026gt;m_w \u0026gt; p.m_w) { return true; } else { return false; } } myclass(int num1, int num2) : m_h(176), m_w(75) { m_h = num1; m_w = num2; } myclass() : m_h(176), m_w(75) {} private: int m_h; int m_w; }; class AddNum { public: int operator()(int num1, int num2) { return num1 + num2; } }; void test01() { myclass p1; myclass p2(160, 45); if(p1 == p2) { cout \u0026lt;\u0026lt; \u0026#34;true\u0026#34; \u0026lt;\u0026lt; endl; } else { cout \u0026lt;\u0026lt; \u0026#34;false\u0026#34; \u0026lt;\u0026lt; endl; } cout \u0026lt;\u0026lt; AddNum()(10, 20) \u0026lt;\u0026lt; endl; } class basetxt { public: void lefttxt() { cout \u0026lt;\u0026lt; \u0026#34;here is left txt\u0026#34; \u0026lt;\u0026lt; endl; } void toptxt() { cout \u0026lt;\u0026lt; \u0026#34;here is top txt\u0026#34; \u0026lt;\u0026lt; endl; } void righttxt() { cout \u0026lt;\u0026lt; \u0026#34;here is right txt\u0026#34; \u0026lt;\u0026lt; endl; } void lesttxt() { cout \u0026lt;\u0026lt; \u0026#34;here is lest txt\u0026#34; \u0026lt;\u0026lt; endl; } }; class page1txt : public basetxt { public: void pagetxt() { cout \u0026lt;\u0026lt; \u0026#34;here is page1 txt\u0026#34; \u0026lt;\u0026lt; endl; } }; class page2txt : public basetxt { public: void pagetxt() { cout \u0026lt;\u0026lt; \u0026#34;here is page2 txt\u0026#34; \u0026lt;\u0026lt; endl; } }; class page3txt : public basetxt { public: void pagetxt() { cout \u0026lt;\u0026lt; \u0026#34;here is page3 txt\u0026#34; \u0026lt;\u0026lt; endl; } }; class page4txt : public basetxt { public: void pagetxt() { cout \u0026lt;\u0026lt; \u0026#34;here is page4 txt\u0026#34; \u0026lt;\u0026lt; endl; } }; void test02() { page1txt().lefttxt(); page1txt().toptxt(); page1txt().righttxt(); page1txt().lesttxt(); page1txt().pagetxt(); cout \u0026lt;\u0026lt; \u0026#34;--------------------\u0026#34; \u0026lt;\u0026lt; endl; page2txt().lefttxt(); page2txt().toptxt(); page2txt().righttxt(); page2txt().lesttxt(); page2txt().pagetxt(); cout \u0026lt;\u0026lt; \u0026#34;--------------------\u0026#34; \u0026lt;\u0026lt; endl; page3txt().lefttxt(); page3txt().toptxt(); page3txt().righttxt(); page3txt().lesttxt(); page3txt().pagetxt(); cout \u0026lt;\u0026lt; \u0026#34;--------------------\u0026#34; \u0026lt;\u0026lt; endl; page4txt().lefttxt(); page4txt().toptxt(); page4txt().righttxt(); page4txt().lesttxt(); page4txt().pagetxt(); cout \u0026lt;\u0026lt; \u0026#34;--------------------\u0026#34; \u0026lt;\u0026lt; endl; } int main() { test01(); cout \u0026lt;\u0026lt; endl; test02(); system(\u0026#34;pause\u0026#34;); } 运算符重载 运算符重载一般用于自定义类之间的运算，可以简化代码，提高代码可读性。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 #include\u0026lt;iostream\u0026gt; using namespace std; class myclass { public: int m_a; int m_b; // 类的构造函数，初始化成员变量m_a和m_b为10 myclass() :m_a(10), m_b(10) {} // 重载+运算符，使其能够用于myclass类型的对象 // 这个函数接受一个myclass类型的对象作为参数，并返回一个新的myclass对象 myclass operator+(myclass\u0026amp; p) { myclass temp; // 创建一个临时的myclass对象，用于存储运算结果 // 将当前对象的m_a与传入对象的m_a相加，结果赋值给临时对象的m_a temp.m_a = this-\u0026gt;m_a + p.m_a; // 将当前对象的m_b与传入对象的m_b相加，结果赋值给临时对象的m_b temp.m_b = this-\u0026gt;m_b + p.m_b; return temp; // 返回临时对象，作为+运算符的结果 } }; int main() { myclass p1; myclass p2; myclass p3; // 使用重载的+运算符，将p1和p2相加，结果赋值给p3 p3 = p1 + p2; cout \u0026lt;\u0026lt; \u0026#34;p3.m_a = \u0026#34; \u0026lt;\u0026lt; p3.m_a \u0026lt;\u0026lt; endl \u0026lt;\u0026lt; \u0026#34;p3.m_b = \u0026#34; \u0026lt;\u0026lt; p3.m_b \u0026lt;\u0026lt; endl; } // 声明一个重载的左移运算符（\u0026lt;\u0026lt;）函数，用于将myclass类的对象信息输出到ostream类型的流中 ostream\u0026amp; operator\u0026lt;\u0026lt;(ostream\u0026amp; cout, myclass\u0026amp; p) { // 使用传入的ostream引用（在这个上下文中通常是cout），输出myclass对象的m_a成员变量的值 cout \u0026lt;\u0026lt; \u0026#34;m_a = \u0026#34; \u0026lt;\u0026lt; p.m_a; // 输出一个换行符，以便将m_a和m_b的输出分开，增加输出的可读性 cout \u0026lt;\u0026lt; endl; // 继续使用cout输出myclass对象的m_b成员变量的值，并在值后面添加一个换行符 cout \u0026lt;\u0026lt; \u0026#34;m_b = \u0026#34; \u0026lt;\u0026lt; p.m_b \u0026lt;\u0026lt; endl; // 返回传入的ostream引用，这里通常是cout，这样函数就可以支持连续的输出操作（链式调用） return cout; } 解释 类定义：myclass 类有两个成员变量 m_a 和 m_b，并通过构造函数初始化为 10。 运算符重载： operator+：重载了加法运算符，使两个 myclass 对象可以相加。返回一个新的 myclass 对象，其成员变量是两个相加对象的对应成员变量的和。 main 函数：创建三个 myclass 对象 p1、p2 和 p3，使用重载的 + 运算符将 p1 和 p2 相加，并将结果赋给 p3，最后输出 p3 的成员变量值。 输出运算符重载：重载了 \u0026lt;\u0026lt; 运算符，使 myclass 对象可以直接输出到标准输出流 cout。 通过这种方式，自定义类的对象可以像基本数据类型一样进行运算和输出，提高了代码的可读性和易用性。\n注意事项 运算符重载不会改变运算符的优先级和结合性。 运算符重载函数可以是成员函数，也可以是友元函数或非成员函数，但一般成员函数和友元函数更为常见。 对于一些非成员函数运算符重载，可能需要将相关的类声明为友元类，以便访问类的私有或受保护成员。 总结 运算符重载是 C++ 中的一个强大特性，允许开发者为自定义类型定义标准运算符的行为。通过重载运算符，可以使自定义类型的使用更加直观和方便。\n全局函数友元 当在类（class）中声明友元（friend）函数后，便可以在全局函数中调用私有对象，示例如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 #include\u0026lt;iostream\u0026gt; using namespace std; class myclass { public: friend void test01(myclass* Myclass); myclass():age(18),weight(70) { } int age; private: int weight; }; void test01(myclass* Myclass) { cout \u0026lt;\u0026lt; \u0026#34;正在访问“age”\u0026#34; \u0026lt;\u0026lt; endl \u0026lt;\u0026lt; \u0026#34;age = \u0026#34; \u0026lt;\u0026lt; Myclass-\u0026gt;age\u0026lt;\u0026lt;endl; cout \u0026lt;\u0026lt; \u0026#34;正在访问“weight”\u0026#34; \u0026lt;\u0026lt; endl \u0026lt;\u0026lt; \u0026#34;age = \u0026#34; \u0026lt;\u0026lt; Myclass-\u0026gt;weight; } int main(){ myclass p1; test01(\u0026amp;p1);//在调用使用指针传输的函数时，传入的数据应为对象的地址或指针 } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 #include\u0026lt;iostream\u0026gt; using namespace std; class myclass { public: friend void test01(myclass\u0026amp; Myclass); myclass():age(18),weight(70) { } int age; private: int weight; }; void test01(myclass\u0026amp; Myclass) { cout \u0026lt;\u0026lt; \u0026#34;正在访问“age”\u0026#34; \u0026lt;\u0026lt; endl \u0026lt;\u0026lt; \u0026#34;age = \u0026#34; \u0026lt;\u0026lt; Myclass.age\u0026lt;\u0026lt;endl; cout \u0026lt;\u0026lt; \u0026#34;正在访问“weight”\u0026#34; \u0026lt;\u0026lt; endl \u0026lt;\u0026lt; \u0026#34;age = \u0026#34; \u0026lt;\u0026lt; Myclass.weight; } int main(){ myclass p1; test01(p1);//在调用使用引用传输的函数时，传入的数据应为对象本身 } 当成员函数访问其他类中私有成员时，应如此声明：\nfriend class01(成员函数所属的类)::void class01test ;\n","date":"2024-11-04T00:00:00Z","image":"http://localhost:1313/images/code1.jpg","permalink":"http://localhost:1313/p/c-/","title":"C++语法笔记"},{"content":"准备阶段 首先，先准备一份客户端，确保你与你的朋友的客户端版本以及mod相同。\n实现远程联机 步骤1：搜索樱花穿透 我们将基于内网穿透来实现远程联机。请在百度搜索“樱花穿透”，访问官方网站：Sakura Frp。\n步骤2：注册并登录 在樱花穿透官方网站注册账号并登录。 步骤3：下载樱花穿透应用程序 下载并安装樱花穿透应用程序。 步骤4：签到获取流量 在管理面板首页签到，以获取免费流量。 步骤5：获取授权码 在管理面板首页获取授权码。 步骤6：使用授权码登录 在樱花穿透应用程序上使用授权码登录。 步骤7：创建端口 创建端口，选择TCP，下面设置改成“我的世界”。 步骤8：完成设置 完成以上设置后，打开游戏，打开局域网链接（如果朋友使用盗版登录链接，请主机先下载联机mod，选择关闭正版验证）。\n步骤9：分享端口码 复制樱花穿透应用程序中给出的端口码，发送给你的朋友让他输入到直接连接中，点击确定。 结果 现在你成功实现用简单的内网穿透远程联机了！\n","date":"2024-11-04T00:00:00Z","image":"http://localhost:1313/images/plc.png","permalink":"http://localhost:1313/p/wdsj/","title":"我的世界JAVA版非局域网远程联机教程"},{"content":"正文测试 这是一段测试用的文字，用于测试新建文章是否成功。\n","date":"2024-11-03T00:00:00Z","image":"http://localhost:1313/helena-hertz-wWZzXlDpMog-unsplash.jpg","permalink":"http://localhost:1313/p/test-chinese-2/","title":"新建文章测试"},{"content":"正文测试 而这些并不是完全重要，更加重要的问题是， 带着这些问题，我们来审视一下学生会退会。 既然如何， 对我个人而言，学生会退会不仅仅是一个重大的事件，还可能会改变我的人生。 我们不得不面对一个非常尴尬的事实，那就是， 可是，即使是这样，学生会退会的出现仍然代表了一定的意义。 学生会退会，发生了会如何，不发生又会如何。 经过上述讨论， 生活中，若学生会退会出现了，我们就不得不考虑它出现了的事实。 学生会退会，到底应该如何实现。 这样看来， 在这种困难的抉择下，本人思来想去，寝食难安。 对我个人而言，学生会退会不仅仅是一个重大的事件，还可能会改变我的人生。 就我个人来说，学生会退会对我的意义，不能不说非常重大。 莎士比亚曾经提到过，人的一生是短的，但如果卑劣地过这一生，就太长了。这似乎解答了我的疑惑。 莫扎特说过一句富有哲理的话，谁和我一样用功，谁就会和我一样成功。这启发了我， 对我个人而言，学生会退会不仅仅是一个重大的事件，还可能会改变我的人生。 学生会退会，到底应该如何实现。 一般来说， 从这个角度来看， 这种事实对本人来说意义重大，相信对这个世界也是有一定意义的。 在这种困难的抉择下，本人思来想去，寝食难安。 了解清楚学生会退会到底是一种怎么样的存在，是解决一切问题的关键。 一般来说， 生活中，若学生会退会出现了，我们就不得不考虑它出现了的事实。 问题的关键究竟为何？ 而这些并不是完全重要，更加重要的问题是。\n奥斯特洛夫斯基曾经说过，共同的事业，共同的斗争，可以使人们产生忍受一切的力量。　带着这句话，我们还要更加慎重的审视这个问题： 一般来讲，我们都必须务必慎重的考虑考虑。 既然如此， 这种事实对本人来说意义重大，相信对这个世界也是有一定意义的。 带着这些问题，我们来审视一下学生会退会。 我认为， 我认为， 在这种困难的抉择下，本人思来想去，寝食难安。 问题的关键究竟为何？ 每个人都不得不面对这些问题。 在面对这种问题时， 要想清楚，学生会退会，到底是一种怎么样的存在。 我认为， 既然如此， 每个人都不得不面对这些问题。 在面对这种问题时， 那么， 我认为， 学生会退会因何而发生。\n引用 思念是最暖的忧伤像一双翅膀\n让我停不了飞不远在过往游荡\n不告而别的你 就算为了我着想\n这么沉痛的呵护 我怎么能翱翔\n最暖的憂傷 - 田馥甄\n图片 1 2 3 ![Photo by Florian Klauer on Unsplash](florian-klauer-nptLmg6jqDo-unsplash.jpg) ![Photo by Luca Bravo on Unsplash](luca-bravo-alS7ewQ41M8-unsplash.jpg) ![Photo by Helena Hertz on Unsplash](helena-hertz-wWZzXlDpMog-unsplash.jpg) ![Photo by Hudai Gayiran on Unsplash](hudai-gayiran-3Od_VKcDEAA-unsplash.jpg) 相册语法来自 Typlog\n","date":"2020-09-09T00:00:00Z","image":"http://localhost:1313/p/test-chinese/helena-hertz-wWZzXlDpMog-unsplash_hu4699868770670889127.jpg","permalink":"http://localhost:1313/p/test-chinese/","title":"Chinese Test"},{"content":"This article offers a sample of basic Markdown syntax that can be used in Hugo content files, also it shows whether basic HTML elements are decorated with CSS in a Hugo theme.\nHeadings The following HTML \u0026lt;h1\u0026gt;—\u0026lt;h6\u0026gt; elements represent six levels of section headings. \u0026lt;h1\u0026gt; is the highest section level while \u0026lt;h6\u0026gt; is the lowest.\nH1 H2 H3 H4 H5 H6 Paragraph Xerum, quo qui aut unt expliquam qui dolut labo. Aque venitatiusda cum, voluptionse latur sitiae dolessi aut parist aut dollo enim qui voluptate ma dolestendit peritin re plis aut quas inctum laceat est volestemque commosa as cus endigna tectur, offic to cor sequas etum rerum idem sintibus eiur? Quianimin porecus evelectur, cum que nis nust voloribus ratem aut omnimi, sitatur? Quiatem. Nam, omnis sum am facea corem alique molestrunt et eos evelece arcillit ut aut eos eos nus, sin conecerem erum fuga. Ri oditatquam, ad quibus unda veliamenimin cusam et facea ipsamus es exerum sitate dolores editium rerore eost, temped molorro ratiae volorro te reribus dolorer sperchicium faceata tiustia prat.\nItatur? Quiatae cullecum rem ent aut odis in re eossequodi nonsequ idebis ne sapicia is sinveli squiatum, core et que aut hariosam ex eat.\nBlockquotes The blockquote element represents content that is quoted from another source, optionally with a citation which must be within a footer or cite element, and optionally with in-line changes such as annotations and abbreviations.\nBlockquote without attribution Tiam, ad mint andaepu dandae nostion secatur sequo quae. Note that you can use Markdown syntax within a blockquote.\nBlockquote with attribution Don\u0026rsquo;t communicate by sharing memory, share memory by communicating.\n— Rob Pike1\nTables Tables aren\u0026rsquo;t part of the core Markdown spec, but Hugo supports supports them out-of-the-box.\nName Age Bob 27 Alice 23 Inline Markdown within tables Italics Bold Code italics bold code A B C D E F Lorem ipsum dolor sit amet, consectetur adipiscing elit. Phasellus ultricies, sapien non euismod aliquam, dui ligula tincidunt odio, at accumsan nulla sapien eget ex. Proin eleifend dictum ipsum, non euismod ipsum pulvinar et. Vivamus sollicitudin, quam in pulvinar aliquam, metus elit pretium purus Proin sit amet velit nec enim imperdiet vehicula. Ut bibendum vestibulum quam, eu egestas turpis gravida nec Sed scelerisque nec turpis vel viverra. Vivamus vitae pretium sapien Code Blocks Code block with backticks 1 2 3 4 5 6 7 8 9 10 \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Code block indented with four spaces \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026quot;en\u0026quot;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026quot;utf-8\u0026quot;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Code block with Hugo\u0026rsquo;s internal highlight shortcode 1 2 3 4 5 6 7 8 9 10 \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Diff code block 1 2 3 4 5 [dependencies.bevy] git = \u0026#34;https://github.com/bevyengine/bevy\u0026#34; rev = \u0026#34;11f52b8c72fc3a568e8bb4a4cd1f3eb025ac2e13\u0026#34; - features = [\u0026#34;dynamic\u0026#34;] + features = [\u0026#34;jpeg\u0026#34;, \u0026#34;dynamic\u0026#34;] List Types Ordered List First item Second item Third item Unordered List List item Another item And another item Nested list Fruit Apple Orange Banana Dairy Milk Cheese Other Elements — abbr, sub, sup, kbd, mark GIF is a bitmap image format.\nH2O\nXn + Yn = Zn\nPress CTRL + ALT + Delete to end the session.\nMost salamanders are nocturnal, and hunt for insects, worms, and other small creatures.\nHyperlinked image The above quote is excerpted from Rob Pike\u0026rsquo;s talk during Gopherfest, November 18, 2015.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"2019-03-11T00:00:00Z","image":"http://localhost:1313/p/markdown-syntax-guide/pawel-czerwinski-8uZPynIu-rQ-unsplash_hu6307248181568134095.jpg","permalink":"http://localhost:1313/p/markdown-syntax-guide/","title":"Markdown Syntax Guide"},{"content":"Lorem est tota propiore conpellat pectoribus de pectora summo.\nRedit teque digerit hominumque toris verebor lumina non cervice subde tollit usus habet Arctonque, furores quas nec ferunt. Quoque montibus nunc caluere tempus inhospita parcite confusaque translucet patri vestro qui optatis lumine cognoscere flos nubis! Fronde ipsamque patulos Dryopen deorum.\nExierant elisi ambit vivere dedere Duce pollice Eris modo Spargitque ferrea quos palude Rursus nulli murmur; hastile inridet ut ab gravi sententia! Nomine potitus silentia flumen, sustinet placuit petis in dilapsa erat sunt. Atria tractus malis.\nComas hunc haec pietate fetum procerum dixit Post torum vates letum Tiresia Flumen querellas Arcanaque montibus omnes Quidem et Vagus elidunt The Van de Graaf Canon\nMane refeci capiebant unda mulcebat Victa caducifer, malo vulnere contra dicere aurato, ludit regale, voca! Retorsit colit est profanae esse virescere furit nec; iaculi matertera et visa est, viribus. Divesque creatis, tecta novat collumque vulnus est, parvas. Faces illo pepulere tempus adest. Tendit flamma, ab opes virum sustinet, sidus sequendo urbis.\nIubar proles corpore raptos vero auctor imperium; sed et huic: manus caeli Lelegas tu lux. Verbis obstitit intus oblectamina fixis linguisque ausus sperare Echionides cornuaque tenent clausit possit. Omnia putatur. Praeteritae refert ausus; ferebant e primus lora nutat, vici quae mea ipse. Et iter nil spectatae vulnus haerentia iuste et exercebat, sui et.\nEurytus Hector, materna ipsumque ut Politen, nec, nate, ignari, vernum cohaesit sequitur. Vel mitis temploque vocatus, inque alis, oculos nomen non silvis corpore coniunx ne displicet illa. Crescunt non unus, vidit visa quantum inmiti flumina mortis facto sic: undique a alios vincula sunt iactata abdita! Suspenderat ego fuit tendit: luna, ante urbem Propoetides parte.\n","date":"2019-03-09T00:00:00Z","image":"http://localhost:1313/p/placeholder-text/matt-le-SJSpo9hQf7s-unsplash_hu10664154974910995856.jpg","permalink":"http://localhost:1313/p/placeholder-text/","title":"Placeholder Text"},{"content":"Mathematical notation in a Hugo project can be enabled by using third party JavaScript libraries.\nIn this example we will be using KaTeX\nCreate a partial under /layouts/partials/math.html Within this partial reference the Auto-render Extension or host these scripts locally. Include the partial in your templates like so: 1 2 3 {{ if or .Params.math .Site.Params.math }} {{ partial \u0026#34;math.html\u0026#34; . }} {{ end }} To enable KaTeX globally set the parameter math to true in a project\u0026rsquo;s configuration To enable KaTeX on a per page basis include the parameter math: true in content files Note: Use the online reference of Supported TeX Functions\nExamples Inline math: $\\varphi = \\dfrac{1+\\sqrt5}{2}= 1.6180339887…$\nBlock math: $$ \\varphi = 1+\\frac{1} {1+\\frac{1} {1+\\frac{1} {1+\\cdots} } } $$","date":"2019-03-08T00:00:00Z","permalink":"http://localhost:1313/p/math-typesetting/","title":"Math Typesetting"},{"content":"Emoji can be enabled in a Hugo project in a number of ways.\nThe emojify function can be called directly in templates or Inline Shortcodes.\nTo enable emoji globally, set enableEmoji to true in your site\u0026rsquo;s configuration and then you can type emoji shorthand codes directly in content files; e.g.\n🙈 :see_no_evil: 🙉 :hear_no_evil: 🙊 :speak_no_evil:\nThe Emoji cheat sheet is a useful reference for emoji shorthand codes.\nN.B. The above steps enable Unicode Standard emoji characters and sequences in Hugo, however the rendering of these glyphs depends on the browser and the platform. To style the emoji you can either use a third party emoji font or a font stack; e.g.\n1 2 3 .emoji { font-family: Apple Color Emoji, Segoe UI Emoji, NotoColorEmoji, Segoe UI Symbol, Android Emoji, EmojiSymbols; } ","date":"2019-03-05T00:00:00Z","image":"http://localhost:1313/p/emoji-support/the-creative-exchange-d2zvqp3fpro-unsplash_hu5876398126655421130.jpg","permalink":"http://localhost:1313/p/emoji-support/","title":"Emoji Support"},{"content":"","date":"0001-01-01T00:00:00Z","permalink":"http://localhost:1313/p/","title":""}]